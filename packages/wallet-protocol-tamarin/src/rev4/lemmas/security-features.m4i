
lemma session_key_secrecy[use_induction]:
  all-traces
    "All K entity X #i
      /* Each time a session key is generated */
      . SessionKey(entity, X, K)@i
      /* and the pin wast not compromised compromised */
      & not (Ex I PIN #k. PinReveal(I, PIN)@k) ==>
        /* the attacker cannot know the secret key */
        not (Ex #k. K(K)@k)
    "


lemma mutual_authentication[use_induction]:
  all-traces
    "All tid pkA pkB entity n #i
      /* Each time entity with pkA commits the use of a nonce
         supposedly generated by an entity with pkB */
      . commit(Nonce, tid, pkA, pkB, entity, n)@i
      /* If the pin was not compromised */
      & not (Ex I PIN #k. PinReveal(I, PIN)@k) ==>
        /* The entity with pkB must be the one that generated this nonce */
        (Ex tid2 entity2 #k
          . running(Nonce, tid2, pkB, pkA, entity2, n)@k
          & not (entity = entity2)
        )
    "


lemma secret_matching[use_induction]:
  "All tid pkA pkB entity K #i
    . commit(SK, tid, pkA, pkB, entity, K)@i
    & not (Ex I #k. DHReveal(I)@k)
      /* If the pin was not compromised */
    & not (Ex I PIN #k. PinReveal(I, PIN)@k) ==>
      (Ex tid2 entity2 #a
        . running(SK, tid2, pkB, pkA, entity2, K)@a
        & not (entity = entity2)
      )
  "


lemma pfs_session_key[use_induction]:
  "All K tid entity pkX pkY #i #j
    /* Each time an entity with pkA commits the use of
       a secret key K generated by an entity with pkB */
    . commit(SK, tid, pkX, pkY, entity, K)@i
    /* if the adversary knows the secret key K, */
    & K(K)@j ==>
      /* the DH private key was compromised before the key commitment */
      (Ex I J PIN #a #b
        . DHReveal(I)@a & #a < #i
        /* and the PIN gets compromised at any time */
        & PinReveal(J, PIN)@b
      ) |
      /* or the PIN was compromised before the key commitment */
      (Ex I PIN #a. PinReveal(I, PIN)@a & #a < #i)
  "
