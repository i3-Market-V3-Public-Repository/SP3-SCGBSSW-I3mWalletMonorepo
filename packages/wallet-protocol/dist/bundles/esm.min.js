import*as t from"@juanelas/base64";import e from"pbkdf2-hmac";import*as r from"object-sha";class s{async send(t,e,r){throw new Error("this transport cannot send messages")}finish(t){t.emit("finished")}}var n={...Object.freeze({__proto__:null,PORT_LENGTH:12,DEFAULT_RANDOM_LENGTH:36,DEFAULT_TIMEOUT:3e4,PORT_SPACE:4096,INITIAL_PORT:29170,NONCE_LENGTH:128,COMMITMENT_LENGTH:256}),...Object.freeze({__proto__:null,RPC_URL_PATH:".well-known/wallet-protocol"})};class i{async generateKeys(){throw new Error("not implemented")}async getPublicKey(){throw new Error("not implemented")}async deriveBits(t){throw new Error("not implemented")}}class a{async randomFill(t,e,r){throw new Error("not implemented")}async randomFillBits(t,e,r){const s=Math.ceil(r/8),n=new Uint8Array(s);await this.randomFill(n,0,s),m.insertBits(n,t,0,e,r)}}class o{constructor(t,e){this.algorithm=t,this.key=e}async encrypt(t){throw new Error("not implemented")}async decrypt(t){throw new Error("not implemented")}}class c{async digest(t,e){throw new Error("not implemented")}}const h=new class extends a{async randomFill(t,e,r){const s=new Uint8Array(r);crypto.getRandomValues(s);for(let n=0;n<r;n++)t[e+n]=s[n]}},u={"aes-256-gcm":{name:"AES-GCM",tagLength:128}};class l extends o{async encrypt(t){const e=new Uint8Array(12);await h.randomFill(e,0,e.length);const r=u[this.algorithm],s=await crypto.subtle.importKey("raw",this.key,r,!1,["encrypt"]),n=await crypto.subtle.encrypt({...r,iv:e},s,t),i=[];return i.push(e),i.push(new Uint8Array(n)),m.join(...i)}async decrypt(t){const e=[];if("aes-256-gcm"===this.algorithm)e[0]=12;e[1]=t.length-e[0];const[r,s]=m.split(t,...e),n=u[this.algorithm],i=await crypto.subtle.importKey("raw",this.key,n,!1,["decrypt"]),a=await crypto.subtle.decrypt({...n,iv:r},i,s);return new Uint8Array(a)}}class d extends i{async generateKeys(){this.keys=await crypto.subtle.generateKey({name:"ECDH",namedCurve:"P-256"},!0,["deriveKey","deriveBits"])}async getPublicKey(){if(void 0===this.keys||void 0===this.keys.publicKey)throw new Error("keys must be initialized fist");const t=await crypto.subtle.exportKey("raw",this.keys.publicKey);return w.u8Arr2Hex(new Uint8Array(t))}async deriveBits(t){if(void 0===this.keys||void 0===this.keys.privateKey)throw new Error("keys must be generated first");const e=w.hex2U8Arr(t),r=await crypto.subtle.importKey("raw",e,{name:"ECDH",namedCurve:"P-256"},!0,[]),s=await crypto.subtle.deriveBits({name:"ECDH",public:r},this.keys.privateKey,256);return new Uint8Array(s)}}const y={sha256:"SHA-256"};const p=new class extends c{async digest(t,e){const r=y[t],s=await crypto.subtle.digest(r,e);return new Uint8Array(s)}},w={utf2U8Arr:t=>(new TextEncoder).encode(t),u8Arr2Utf:t=>(new TextDecoder).decode(t),num2U8Arr:(t,e)=>{if(void 0===e)for(e=1;2**(8*e)<t;)e++;const r=new Uint8Array(e);let s=t;for(let t=e-1;t>=0;t--){const e=s>>8,n=s-(e<<8);r[t]=n,s=e}return r},u8Arr2Num:t=>{let e=0;for(let r=0;r<t.length;r++)e+=t[r]<<t.length-1-r;return e},hex2U8Arr:t=>{const e=t.match(/.{1,2}/g);if(null===e)throw new Error(`not a hex: ${t}`);return new Uint8Array(e.map((t=>parseInt(t,16))))},u8Arr2Hex:t=>t.reduce(((t,e)=>t+e.toString(16).padStart(2,"0")),""),u8Arr2Base64:e=>t.encode(e,!0,!1),base642U8Arr:e=>t.decode(e,!1)},m={join:(...t)=>{const e=t.reduce(((t,e)=>t+e.length),0),r=new Uint8Array(e);let s=0;for(const e of t)r.set(e,s),s+=e.length;return r},split:(t,...e)=>{const r=[];let s=0;for(const n of e)r.push(t.slice(s,s+n)),s+=n;return r},insertBytes:(t,e,r,s,n)=>{for(let i=0;i<n;i++)e[i+s]=t[i+r]},insertBits:(t,e,r,s,n)=>{let i=Math.floor(r/8),a=r%8,o=Math.floor(s/8),c=s%8,h=t[i]??0;const u=c-a;for(let r=0;r<n;r++){let r;r=u>=0?(h&128>>a)<<u:h&128>>a;const s=e[o]&~(128>>c)|r;e[o]=s,a++,c++,a>=8&&(i++,a=0,h=t[i]??0),c>=8&&(o++,c=0)}},extractBits:(t,e,r)=>{const s=Math.ceil(r/8),n=new Uint8Array(s);return m.insertBits(t,n,e,0,r),n}};class g{get promise(){return this.createPromise()}async createPromise(){return await new Promise(((t,e)=>{this.resolve=t,this.reject=e}))}next(t){null!=this.resolve&&this.resolve(t)}err(t){null!=this.reject&&this.reject(t)}}class f{constructor(){this.events={}}on(t,e){return void 0===this.events[t]&&(this.events[t]=[]),this.events[t].push(e),this}emit(t,...e){const r=this.events[t];return void 0!==r&&(r.forEach((t=>t(...e))),!0)}}const A=async(t,r,s)=>{const n=new Uint8Array(16),i=new Uint8Array(96),a=w.hex2U8Arr(t),o=w.hex2U8Arr(r);m.insertBytes(s,i,0,0,32),m.insertBytes(a,i,0,32,32),m.insertBytes(o,i,0,64,32);const c=await e(i,n,1,32);return new Uint8Array(c)};class b{constructor(t,e,r,s,n,i,a,o){this.port=t,this.from=e,this.to=r,this.na=s,this.nb=n,this.secret=i,this.cipher=new l("aes-256-gcm",a),this.decipher=new l("aes-256-gcm",o)}async encrypt(t){return await this.cipher.encrypt(t)}async decrypt(t){return await this.decipher.decrypt(t)}toJSON(){return{from:this.from,to:this.to,port:this.port,na:w.u8Arr2Base64(this.na),nb:w.u8Arr2Base64(this.nb),secret:w.u8Arr2Base64(this.secret)}}async fromHash(){return await r.digest(this.from)}async toHash(){return await r.digest(this.to)}static async fromSecret(t,e,s,n,i,a){const o=await r.digest(e),c=await r.digest(s),h=await A(o,c,a),u=await A(c,o,a);return new b(t,e,s,n,i,a,h,u)}static async fromJSON(t){const e=w.base642U8Arr(t.na),r=w.base642U8Arr(t.nb),s=w.base642U8Arr(t.secret);return await this.fromSecret(t.port,t.from,t.to,e,r,s)}}class x{constructor(t,e,r){this.transport=t,this.masterKey=e,this.code=r}async send(t){return await this.transport.send(this.masterKey,this.code,t)}toJSON(){return{masterKey:this.masterKey.toJSON(),code:w.u8Arr2Hex(this.code)}}static async fromJSON(t,e){const r=await b.fromJSON(e.masterKey),s=w.hex2U8Arr(e.code);let n;if("object"==typeof t)n=t;else{if(!(t instanceof Function))throw new Error("First param must be transport or constructor of transport");n=new t}return new x(n,r,s)}}class U extends f{constructor(t){super(),this.transport=t}async computeR(t,e){return t.map(((t,r)=>t^e[r]))}async computeNx(){const t=Math.ceil(n.NONCE_LENGTH/8),e=new Uint8Array(t);return await h.randomFillBits(e,0,n.NONCE_LENGTH),e}async computeCx(t,e,r){const s=Math.ceil(n.NONCE_LENGTH/8),i=Math.ceil(n.DEFAULT_RANDOM_LENGTH/8),a=w.hex2U8Arr(t.a.publicKey),o=w.hex2U8Arr(t.b.publicKey),c=new Uint8Array(64+s+i);m.insertBytes(a,c,1,0,32),m.insertBytes(o,c,1,32,32),m.insertBits(e,c,0,512,n.NONCE_LENGTH),m.insertBits(r,c,0,512+n.NONCE_LENGTH,n.DEFAULT_RANDOM_LENGTH);return await p.digest("sha256",c)}async validateAuthData(t,e){const{cx:r,nx:s}=e.received,{cx:n,nx:i,r:a}=e.sent;if(!(r.length===n.length&&s.length===i.length))throw new Error("invalid received auth data length");if(r.every(((t,e)=>t===n[e])))throw new Error("received and sent Cx are the same");if(!(await this.computeCx(t,s,a)).every(((t,e)=>t===r[e])))throw new Error("received a wrong Cx")}async computeMasterKey(t,s,i){const a=Math.ceil(n.NONCE_LENGTH/8),o=await t.deriveBits(s.received.publicKey),c=new Uint8Array(16),h=new Uint8Array(32+2*a+6+64),u=new Uint8Array([109,97,115,116,101,114]),l=await r.digest(s.a,"SHA-256"),d=w.hex2U8Arr(l),y=await r.digest(s.b,"SHA-256"),p=w.hex2U8Arr(y);m.insertBytes(o,h,0,0,32),m.insertBytes(i.a.nx,h,0,32,a),m.insertBytes(i.a.nx,h,0,32+a,a),m.insertBytes(u,h,0,32+2*a,6),m.insertBytes(d,h,0,32+2*a+6,32),m.insertBytes(p,h,0,32+2*a+6+32,32);const g=await e(h,c,1,32);return await b.fromSecret(s.port,s.sent.id,s.received.id,i.a.nx,i.b.nx,new Uint8Array(g))}async run(){return await(async()=>{const t=new d;await t.generateKeys();const e=await t.getPublicKey(),r=await this.transport.prepare(this,e),s=await this.transport.publicKeyExchange(this,r),n=await this.computeR(s.a.rx,s.b.rx),i=await this.computeNx(),a={r:n,nx:i,cx:await this.computeCx(s,i,n)},o=await this.transport.authentication(this,a);await this.validateAuthData(s,o);const c=await this.computeMasterKey(t,s,o),h=await this.transport.verification(this,c),u=new x(this.transport,c,h);return this.emit("masterKey",c),u})().finally((()=>{this.transport.finish(this)}))}on(t,e){return super.on(t,e)}emit(t,...e){return super.emit(t,...e)}}class E{constructor(t,e){this.buffer=t,this.l=e}toString(){return w.u8Arr2Base64(this.buffer)}extractPort(){const t=Math.ceil(n.PORT_LENGTH/8),e=this.l%8,r=new Uint8Array(t);m.insertBits(this.buffer,r,this.l,e,n.PORT_LENGTH);const s=w.u8Arr2Num(r);return n.INITIAL_PORT+s}extractRb(){return m.extractBits(this.buffer,0,this.l)}static async generate(t,e){const r=Math.ceil((e+n.PORT_LENGTH)/8),s=new Uint8Array(r);await h.randomFillBits(s,0,e);const i=t-n.INITIAL_PORT;if(i<0||i>n.PORT_SPACE)throw new Error(`the port ${t} is out of the port space`);const a=w.num2U8Arr(i,2);return m.insertBits(a,s,16-n.PORT_LENGTH,e,n.PORT_LENGTH),new E(s,e)}static fromString(t,e){return new E(w.base642U8Arr(t),e)}}const N={async generate(t){console.warn("Using the default code verifier. Note that it is not secure for production.");const e=await t.toJSON();return w.utf2U8Arr(JSON.stringify(e))},async getMasterKey(t){const e=w.u8Arr2Utf(t);return await b.fromJSON(JSON.parse(e))}};class S extends s{constructor(t={}){super(),this.opts={host:t.host??"localhost",id:t.id??{name:"Initiator"},l:t.l??n.DEFAULT_RANDOM_LENGTH,getConnectionString:t.getConnectionString??(async()=>{throw new Error("getConnectionString must be provided")})}}async prepare(t,e){const r=await this.opts.getConnectionString();if(""===r)throw new Error("empty connection string");this.connString=E.fromString(r,this.opts.l);const s=Math.ceil(this.opts.l/8),n=new Uint8Array(s);return await h.randomFillBits(n,0,this.opts.l),{id:this.opts.id,publicKey:e,rx:n}}async publicKeyExchange(t,e){if(void 0===this.connString)throw new Error("missing connection string");const r=await this.sendRequest({method:"publicKeyExchange",sender:this.opts.id,publicKey:e.publicKey,ra:w.u8Arr2Base64(e.rx)}),s={id:r.sender,publicKey:r.publicKey,rx:this.connString.extractRb()};return{a:e,b:s,port:this.connString.extractPort(),sent:e,received:s}}async authentication(t,e){const r=await this.sendRequest({method:"commitment",cx:w.u8Arr2Base64(e.cx)}),s=await this.sendRequest({method:"nonce",nx:w.u8Arr2Base64(e.nx)}),n={cx:w.base642U8Arr(r.cx),nx:w.base642U8Arr(s.nx),r:e.r};return{a:e,b:{cx:w.base642U8Arr(r.cx),nx:w.base642U8Arr(s.nx),r:e.r},sent:e,received:n}}async verification(t,e){const r=await this.sendRequest({method:"verification"}),s=w.base642U8Arr(r.ciphertext);return await e.decrypt(s)}finish(t){super.finish(t),this.connString=void 0}}class v extends S{buildRpcUrl(t){return`http://${this.opts.host}:${t}/${n.RPC_URL_PATH}`}async baseSend(t,e){{const r=this.buildRpcUrl(t),s=await fetch(r,e),n=await s.text();return{status:s.status,body:n}}}async sendRequest(t){if(void 0===this.connString)throw new Error("cannot connect to the rpc yet: port missing");const e=this.connString.extractPort(),r=await this.baseSend(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(t)});return JSON.parse(r.body)}async send(t,e,r){const s=w.utf2U8Arr(JSON.stringify(r)),n=await t.encrypt(s),i=await this.baseSend(t.port,{method:"POST",headers:{Authorization:w.u8Arr2Utf(e)},body:w.u8Arr2Base64(n)});if(i.status<=300&&i.status>=200){const e=w.base642U8Arr(i.body),r=await t.decrypt(e);i.body=w.u8Arr2Utf(r)}return i}}class T extends s{constructor(t={}){super(),this.opts={port:t.port??n.INITIAL_PORT,timeout:t.timeout??n.DEFAULT_TIMEOUT,id:t.id??{name:"Responder"},l:t.l??n.DEFAULT_RANDOM_LENGTH,codeGenerator:t.codeGenerator??N},this.rpcSubject=new g}async pairing(t,e,r){this.stopPairing(),this.connString=await E.generate(e,this.opts.l),this.lastPairing=setTimeout((()=>{this.stopPairing(),this.finish(t)}),r)}stopPairing(){null!=this.lastPairing&&(clearTimeout(this.lastPairing),this.lastPairing=void 0)}get isPairing(){return void 0!==this.connString}get port(){return this.opts.port}get timeout(){return this.opts.timeout}async prepare(t,e){if(await this.pairing(t,this.port,this.timeout),null===this.connString||void 0===this.connString)throw new Error("could not generate connection string");return t.emit("connString",this.connString),{id:this.opts.id,publicKey:e,rx:this.connString.extractRb()}}async waitRequest(t){for(;;){const e=await this.rpcSubject.promise;if(e.req.method===t)return e}}async publicKeyExchange(t,e){if(void 0===this.connString)throw new Error("protocol not properly initialized");const{req:r,res:s}=await this.waitRequest("publicKeyExchange");await s.send({method:"publicKeyExchange",sender:e.id,publicKey:e.publicKey});const n={id:r.sender,publicKey:r.publicKey,rx:w.base642U8Arr(r.ra??"")};return{a:n,b:e,port:this.connString.extractPort(),sent:e,received:n}}async authentication(t,e){const r=await this.waitRequest("commitment");await r.res.send({method:"commitment",cx:w.u8Arr2Base64(e.cx)});const s=r.req,n=await this.waitRequest("nonce");await n.res.send({method:"nonce",nx:w.u8Arr2Base64(e.nx)});const i=n.req,a={cx:w.base642U8Arr(s.cx),nx:w.base642U8Arr(i.nx),r:e.r};return{a:a,b:e,sent:e,received:a}}async verification(t,e){const r=await this.waitRequest("verification"),s=await this.opts.codeGenerator.generate(e),n=await e.encrypt(s);return await r.res.send({method:"verificationChallenge",ciphertext:w.u8Arr2Base64(n)}),s}finish(t){super.finish(t),this.stopPairing(),this.rpcSubject.err("Finished"),this.connString=void 0}}class O{}class P extends O{constructor(t){super(),this.res=t}async send(t){this.res.write(JSON.stringify(t)),this.res.end()}}class B extends T{constructor(t){super(t),this.listeners=[],this.rpcUrl=t?.rpcUrl??`/${n.RPC_URL_PATH}`}async readRequestBody(t){const e=[];for await(const r of t)e.push(r);return Buffer.concat(e).toString()}async dispatchProtocolMessage(t,e){if(!this.isPairing)throw new Error("not in pairing mode");const r=await this.readRequestBody(t),s=JSON.parse(r);this.rpcSubject.next({req:s,res:new P(e)})}async dispatchEncryptedMessage(t,e,r){const s=w.utf2U8Arr(r),n=await this.opts.codeGenerator.getMasterKey(s),i=await this.readRequestBody(t),a=w.base642U8Arr(i),o=await n.decrypt(a),c=w.u8Arr2Utf(o),h=JSON.parse(c);let u={};const l=h.init??{};void 0!==l.body&&""!==l.body&&(u=JSON.parse(l.body));const d=Object.entries(l.headers??{}).reduce(((t,[e,r])=>(t[e.toLocaleLowerCase()]=r,t)),t.headers),y=new Proxy(t,{get(t,e){switch(e){case"url":return h.url;case"method":return l.method;case"headers":return d;case"_body":case"walletProtocol":return!0;case"body":return u;default:return t[e]}}});e.end=new Proxy(e.end,{apply:(t,r,s)=>{const i=void 0===r.statusCode?500:r.statusCode;if(i>=200&&i<300){const i=s[0],a=async()=>{let a;if("string"==typeof i)a=w.utf2U8Arr(i);else{if(!(i instanceof Buffer))throw new Error("cannot manage this chunk...");a=i}const o=await n.encrypt(a),c=w.u8Arr2Base64(o);e.setHeader("Content-Length",c.length),t.call(r,c,...s.slice(1))};a().catch((t=>{console.error(t)}))}else t.call(r,...s)}}),await this.callListeners(y,e)}async dispatchRequest(t,e){if(t.url===this.rpcUrl){if("POST"!==t.method)throw new Error("method must be POST");return void 0!==t.headers.authorization?await this.dispatchEncryptedMessage(t,e,t.headers.authorization):await this.dispatchProtocolMessage(t,e)}await this.callListeners(t,e)}async callListeners(t,e){for(const r of this.listeners)r(t,e)}use(t){this.listeners.push(t)}}export{s as BaseTransport,E as ConnectionString,v as HttpInitiatorTransport,B as HttpResponderTransport,b as MasterKey,x as Session,U as WalletProtocol,n as constants,N as defaultCodeGenerator};
